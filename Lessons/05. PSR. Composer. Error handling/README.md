## Ошибки и исключения

### Терминология

1. Ошибочная ситуация — факт наличия ошибки в программе. Синтаксическая (пропущенная скобка) или семантическая (
   например, обращение к необъявленной переменной).

1. Внутренняя ошибка, генерируемая интерпретатором (например, открытие несуществующего файла) или кодом PHP (например,
   непройденная валидация данных). Не рекомендуется показывать пользователю, но есть смысл логировать.

1. Пользовательское сообщение об ошибке — генерируется и обрабатывается самой программой. Пригодна для показа
   пользователю.

Зачастую, пункты 2 и 3 работают совместно - в лог пишется техническая информация внутренней ошибки, а пользователю
показывается релевантное сообщение об ошибке.

### Виды ошибок

При возникновении ошибки, нужно принять решение, что делать дальше. Код, который служит для обработки такой ситуации
называется кодом восстановления после ошибки.

```injectablephp
$f = @fopen("spoon.txt","r"); 
if (!$f) {return;} //код восстановления: нужно выйти из программы
```

Ошибки можно разделить на серьёзные (фатальные) - которые нужно обязательно как-то обработать, иначе дальше нельзя
работать и несерьёзные - дальше работать можно, но нужно разобраться, почему такая ситуация возникает.

### Контроль ошибок

Настройка, какие ошибки показывать пользователю, а какие подавлять, производится несколькими способами:

1. Директива error_reporting. Флаговое значение, по умолчанию - E_ALL~E_NOTICE в проде и E_ALL в разработке.
   Устанавливается в php.ini, .htaccess или функцией ini_set(). Устанавливает "уровень строгости" контроля ошибок в PHP.

1. display_errors и log_errors устанавливают, показывать ли сообщения пользователю и записывать ли в лог, соответственно

1. error_log - абсолютный путь к файлу лога.

1. функция int error_reporting([int $level]) - устанавливает или отображает значение директивы из п.1.

Уровень отображения ошибок следует всегда различать в среде разработки (на своём ПК или дев-сервере) и в продуктовой
среде (то, что увидит пользователь). Есть несколько способов это сделать: либо в php.ini/.htacess сервера (один и тот же
код с разными настройками), либо определять в деве мы или в проде внутри кода и использовать ini_set для установки
параметров отображения ошибок.

### Оператор отключения ошибок

Если перед любым выражением поставить @, ошибки в этом выражении не будут выведены пользователю. Не рекомендуется
использовать в большинстве случаев, но в некоторых частных - можно. Например, если ошибку в этом месте мы уже
обрабатываем каким-то другим способом, как в примере выше. Оператор @ предпочтительнее отключения ошибок, но нужно
применять с осторожностью. Ни в коем случае не применять перед include/require, не стоит применять перед сложными
вызовами со вложенными функциями. Относительно безопасно применять в конструкциях вроде

```injectablephp
if (@$_REQUEST['key']) 
{
 //...
}
```

### Исключения

Механизм обработки исключений позволяет в удобной форме писать код восстановления, значительно упрощая обработку и
генерацию ошибок. В PHP исключение — это специальный класс-наследник базового класса Exception. Код нашего скрипта (или
подключаемой библиотеки) может "выкидывать" ошибку, которая будет перехватываться специальным блоком кода.

```injectablephp
try {
//...  здесь перехватывается возникшее исключение
}
catch (Exception $e) {
//... код обработки исключения
}
finally {
//...
}
```

Класс __Exception__ хранит разную информацию об ошибке, в том числе сообщение и код ошибки.

Иногда нужно выполнить некоторый код, даже если было выброшено некоторое исключение или произошла ошибка. Для этого
существует блок __finally__. Он выполняется независимо от того, был ли выполнен блок try до конца или была выброшена
ошибка (перехваченная или не перехваченная соответствующим catch). Разумеется, финализатор не отработает, если
произойдёт физический сбой или процесс php будет закрыт ОС. Но существуют и менее очевидные исключения: например, при
выполнении команды __exit__ или __die__, завершающих выполнение скрипта, или при возникновении ошибки внутри catch. Это
всегда следует иметь в виду.

Для генерации исключения используется инструкция

```injectablephp
throw new Exception("Message");
```

Эта команда немедленно прерывает выполнение текущего кода, если использована внутри try и для него определён catch
соответствующего типа — выполнится код этого catch. Затем, если определён __finally__, выполнится его код. При этом
происходит "раскручивание стека": если ошибка возникла в некоторой функции и не перехвачена в ней, произойдёт выход из
функции и далее вверх по стеку, пока не найдётся подходящий catch. Если так и не найдётся, программа будет завершена.

Для одного try можно определить несколько catch с разными типами исключений. Они должны следовать одно за другим:

```injectablephp
try { 
//... 
}
catch (SomeExceptionChild $e) { 
//...
}
catch (SomeOtherException $e) { 
//...
}
```

Вызовется только первый обработчик, исключение которого подойдёт по иерархии наследования (т.е. будет предком
выброшенного). Это позволяет по-разному обрабатывать разные ошибки (например, показывать разные сообщения пользователю).

#### Методы базового Exception

* __construct([string $message[, int $code]]) - при создании исключения можно задавать сообщение и код ошибки, остальное
  PHP заполнит автоматически.
* getMessage() - возвращает текст сообщения
* getCode() - возвращает код ошибки
* getFile() - возвращает имя файла, где возникла ошибка
* getLine() - возвращает номер строки, где возникла ошибка
* getTrace() - возвращает стек вызовов в виде списка
* getTraceAsString() - возвращает стек вызовов в виде строки
* __toString() - возвращает всю вышеприведённую информацию (в читаемом формате).

Кроме конструктора и приведения к строке, остальные методы __final__.

#### Классификация Exception

При сложной структуре обработки исключений, рекомендуется выделять интерфейсы, основным назначением которых будет именно
классификация ошибок. Это позволит обойти ограничение на множественное наследование, если в разных ситуациях одно и то
же исключение может трактоваться по-разному. Например, ошибка записи файла на удалённый сервер может трактоваться как
сетевая или файловая.

### Error

Ошибки, которые генерирует сам PHP не являются наследниками Exception и не отловятся блоком catch (Exception $e).
Начиная с PHP 7, блок catch умеет ловить реализации интерфейса Throwable, который реализуют и базовый Exception (значит
и его наследники), и базовый Error. Категорически не рекомендуется использовать catch (Throwable $t). Идеологически
Error и Exception всё ещё совершенно разные типы ошибок, лучше использовать для них 2 (или больше — для поимки разных
видов наследников) catch.

## PSR

### Виды стандартов

Для упрощения интеграции компонентов между различными фреймворками, PHP-FIG (Framework Integration Group) разработала
ряд стандартов (по факту это всё же рекомендации) для разработчиков, называемых PHP Standart Recommendation (PSR). На
данный момент их 22 (включая устаревшие и находящиеся в разработке), мы рассмотрим 5, с остальными можно
ознакомиться [тут](https://www.php-fig.org/) :

* PSR-1 - основной стандарт кодирования
* PSR-12 - руководство по стилю кода
* PSR-3 - стандарт протоколирования
* PSR-4 - стандарт автозагрузки классов
* PSR-7 - стандарт HTTP-сообщения

### PSR-1. Основной стандарт кодирования

* PHP-теги: PSR позволяет использовать ```<?php … ?> и <?= … ?>```. Остальные устарели иди запрещены
* Кодировка UTF-8: существует 2 разновидности кодировки UTF-8: с BOM и без BOM. PSR позволяет только второй вариант.
* Разделение объявлений и выполнения действий: в одном файле либо объявление классов, функций и констант, либо прямое
  выполнение кода, но не то и другое вместе. Исключение для условного объявления функций.
* Пространство имён: каждый класс обязательно со своим пространством имён; каждый класс в отдельном файле. Подробнее в
  PSR-4.

#### Правила именования

* Для именования классов использовать CamelCase - в одно слово, без подчёркиваний, каждое слово - с прописной буквы:
  HelloWorld, SwiftStorage
* Для именования методов использовать lowerCamelCase - CamelCase со строчной буквы: sendByHttp(), setParam()
* Константы классов записываются ВСЕМИ_ПРОПИСНЫМИ_С_ПОДЧЁРКИВАНИЯМИ: HELLO_WORLD, IS_STATIC_PAGE

#### PSR-12

Продолжением стандарта PSR-1 раньше был PSR-2. На данный момент он признан устаревшим и заменён PSR-12

Пример из документации, иллюстрирующий PSR-12:

```injectablephp
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // method body
    }
}

```

* Код должен следовать требованиям PSR-1
* Файлы:
    * Файлы кода должны в качестве символа конца строки использовать \n (linefeed, формат Unix)
    * Файлы кода должны заканчиваться на пустую строку (файл должен заканчиваться на \n)
    * Если в файле только PHP-код, закрывающего тега ?> быть не должно
* Строки
    * Жёсткого лимита на длину строки нет, но рекомендуется не более 120 символов, а в идеале — не более 80
    * В конце строки не должно быть пробелов
    * Допустимо использовать пустые строки для разделения блоков кода и повышения читаемости
    * Не более одной операции на строку
* Отступ: 4 пробела на каждый уровень, никаких знаков табуляции
* Ключевые слова (if, true/false, int и т.д.) должны быть написаны маленькими буквами
* Если у ключевого слова есть полная и краткая форма, следует использовать краткую: int, а не integer; bool, а не
  boolean и т.д.
* Блоки в начале файла должны идти в определённом порядке, их нужно отделять друг от друга пустыми строками, а внутри
  блоков не должно быть пробелов:
    1. Открывающий тег <?php, больше ничего в этой строке не должно быть
    1. docblock файла
    1. declare
    1. namespace
    1. use классов
    1. use функций
    1. use констант
* Однотипные неймспейсы можно группировать следующим образом:

```injectablephp
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

но внутри перечисления должны быть куски не больше 2 уровней, как в примере.

* Классы, свойства и методы. Все правила для классов должны выполняться так же для интерфейсов и трейтов.
    * После закрывающей фигурной скобки не должно быть в той же строке комментариев или кода
    * При использовании new даже если используется конструктор без параметров нужно использовать ()
    * Ключевые слова __extends__ и __implements__ должны быть на одной строке с именем класса.
    * Закрывающие } должны быть на новой строке и пустая строка перед ними не нужна
    * Список в __implements__ и (в случае интерфейсов) __extends__ могут быть разбиты на несколько строк и тогда каждая
      запись должна быть на отдельной строке, в том числе 1-й элемент должен быть на следующей строке после ключевого
      слова

    ```injectablephp
      class ClassName extends ParentClass implements
          ArrayAccess,
          Countable,
          Serializable
      {
        // constants, properties, methods
      }
    ```

    * __use__ внутри класса для подключения трейтов должны идти сразу после открывающей {, по 1 на строку. После блока
      __use__ нужна пустая строка, если только на этом класс не заканчивается.
    * Правила форматирования __insteadof__ и __as__ такие: открывающая { на одной строке с __use__, затем по 1 записи на
      строку, } на новой строке:
  ```injectablephp
    <?php

      class Talker
      {
        use A;
        use B {
          A::smallTalk insteadof B;
        }
        use C {
          B::bigTalk insteadof C;
          C::mediumTalk as FooBar;
        }
      }
  ```
    * Свойства и константы
        * Для каждого свойства нужно указывать видимость
        * Для каждой константы нужно указывать видимость (PHP 7.1+)
        * Нельзя использовать var для объявления свойства
        * Каждое свойство должно быть объявлено отдельным выражением
        * _ в начале имени не должно использоваться для обозначения приватности

    * Методы и функции
        * Для всех методов нужно указывать видимость
        * _ в начале имени не должно использоваться для обозначения приватности метода
        * После названия метода или функции не должно быть пробела перед ()
        * { и } на отдельной строке, без пустых строк после { и перед }
        * В списке аргументов нужен пробел после каждой запятой, но не перед зепятой
        * Список аргументов можно делить на несколько строк, тогда первый аргумент и все последующие - с новой строки,
          а ) { на отдельной строке и между ними 1 пробел. Объявление типа — на той же строке, что и сам аргумент
        * Для Nullable-типов между ? и типом не должно быть пробелов (?string - string или null, ?int - int или null)
        * При передаче по ссылке между & и типом не должно быть пробелов
        * __abstract__ и __final__ должны идти перед объявлением видимости, __static__ - после
        * При вызове функций не должно быть пробелов между объектом и ->, -> и методом, методом и (), между аргументом и
          запятой после него. Пробел нужен только после запятой в списке аргументов. Как и при объявлении, при вызове
          аргументы можно писать в столбик, по 1 на строку (кроме случаев, когда сам аргумент разделён на несколько
          строк, например, если аргумент — это анонимная функция)

    * Контрольные структуры (if, for/while/foreach, switch и т.д.)
        * После ключевого слова - 1 пробел
        * После ( и перед ) пробел не нужен
        * Между ) и { - 1 пробел
        * Тело на 1 отступ
        * Тело со следующей строки после {, } на следующей строке после тела, {} нужны даже если всего 1 строка
        * Из __else if__ и __elseif__ предпочтителен слитный вариант. __else__ и __elseif__ должны быть в той же строке,
          что и } предыдущего блока, через 1 пробел.
        * Выражение внутри __if__ можно делить на строки, смещённые минимум на 1 отступ, первая часть так же с новой
          строки.

    * Операторы
        * В унарных операторах между оператором и операндом не должно быть пробелов.
      ```injectablephp
            ++$i;
            $i++;
      ```
        * В операторе приведения типа не должно быть пробелов внутри скобок

        ```injectablephp
            $intValue = (int) $input;
        ```

        * Бинарные операторы должны быть выделены хотя бы 1 пробелом
        ```injectablephp
            if ($a === $b) {
                $foo = $bar ?? $a ?? $b;
            } elseif ($a > $b) {
                $foo = $a + $b * $c;
            }
        ```

        * В тернарном операторе ? и : должны быть выделены пробелами справа и слева, если среднего операнда нет - между
          ? и : пробел не нужен

#### PSR-3. Протоколирование

Описывает реализацию логирования (оно же журналирование). Класс, выполняющий логирование, должен реализовывать
Psr\Log\LoggerInterface. Предусматривается 8 уровней критичности логируемого события, согласно RFC 5424: debug, info,
notice, warning, error, critical, alert, emergency. Для этого объявлен метод log, позволяющий передавать уровен
логирования первым аргументом, а так же 8 конкретных методов, по 1 на каждый уровень.

```injectablephp
interface LoggerInterface
{
    public function emergency($message, array $context = []);
    public function alert($message, array $context = []);
    public function critical($message, array $context = []);
    public function error($message, array $context = []);
    public function warning($message, array $context = []);
    public function notice($message, array $context = []);
    public function info($message, array $context = []);
    public function debug($message, array $context = []);
    public function log($level, $message, array $context = []);
}

```

#### PSR-4. Автозагрузка

Классы, поддерживающие автозагрузку должны соблюдать следующие требования:

* Каждый класс должен находиться в пространстве имён вида:

  \<ПространствоИмён>(\<ПодпространствоИмён>)*\<ИмяКласса>

* Каждый класс - в отдельном файле с названием <ИмяКласса>.php
* Файл кода - в папке по пути \\<ПространствоИмён>(\\<ПодпространствоИмён>)*

#### PSR-7. HTTP-сообщения

Описывает структуру обёрточных классов для работы с HTTP-запросами и ответами. Интерфейс верхнего уровня - 
__MessageInterface__, от него наследуются __RequestInterface__ и __ResponseInterface__; от
__RequestInterface__ наследуется __ServerRequestInterface__ для описания запросов со стороны сервера.

```injectablephp
namespace Psr\Http\Message;

interface MessageInterface
{
    public function getProtocolVersion();
    public function withProtocolVersion($version);
    public function getHeaders();
    public function hasHeader($name);
    public function getHeader($name);
    public function getHeaderLine($name);
    public function withHeader($name, $value);
    public function withAddedHeader($name, $value);
    public function withoutHeader($name);
    public function getBody();
    public function withBody(StreamInterface $body);
}

```

getProtocolVersion() - возвращает версию HTTP-протокола, "1.0" или "1.1"

* withProtocolVersion($version) - задаёт версию протокола
* getHeaders() - возвращает список заголовков в виде массива
* hasHeader($name) - возвращает true, если есть заголовок $name
* getHeader($name) - возвращает заголовок по имени или массив, если их несколько
* getHeaderLine($name) - возвращает заголовок по имени или строку, в которой значения разделены
* запятой, если их несколько
* withHeader($name, $value) - устанавливает заголовок $name со значением $value
* withAddedHeader($name, $value) - устанавливает дополнительное значение уже существующего заголовка
* withoutHeader($name) - удаляет указанный заголовок
* getBody() - возвращает HTTP - документ без заголовков
* withBody(StreamInterface $body) - устанавливает содержимое для тела сообщения при помощи объекта, реализующего
  интерфейс StreamInterface, т.к. тело может быть большим и не помещаться в память.

##### Ответ сервера ResponseInterface

Добавляются следующие методы:

* getStatusCode() - возвращаеть HTTP-код ответа
* withStatus($code, $reasonPhrase = '') - устанавливает код ответа и поясняющую фразу
* getReasonPhrase()  - возвращает поясняющую фразу.

##### Запрос клиента RequestInterface

Добавляются следующие методы:

* getRequestTarget() - возвращает цель запроса, например, /params/get.php?id=123456 или *
* withRequestTarget($requestTarget) - устанавливает цель запроса
* getMethod()  - возвращает HTTP-метод (GET, POST, и т.д.)
* withMethod($method) - задаёт HTTP-метод
* getUri() - возвращает URI
* withUri(UriInterface $uri, $preserveHost = false) - устанавливает URI запроса, если второй аргумент true, адрес
  сервера извлекается из HTTP-заголовка Host.

##### Запрос с точки зрения сервера ServerRequestInterface

В интерфейс добавляются методы, позволяющие получить содержимое суперглобальных массивов, распарсить cookie и т.д.

* getServerParams() - получает переменные окружения ($_SERVER)
* getCookieParams() и withCookieParams() - получает и устанавливает $_COOKIES
* getQueryParams() и withQueryParams() - аналогично для $_GET
* getParsedBody() и withParsedBody() - аналогично для $_POST
* getAttributes() - получение $_REQUEST
* withAttribute($name, $value) - позволяет добавить параметр в виде GET-параметра URI.
* withoutAttribute($name) - позволяет удалить параметр.

## Composer

В PHP существует множество фреймворков - Yii, Sympfony, Zend, Phalcon, Laravel и т.д., но нет какого-то единого
флагмана, который бы использовали "почти все". Поэтому разработчики фреймворков пошли по пути выработки стандартов
модулей, которые бы работали в любом фреймворке.

Компонентом или библиотекой называют коллекцию связанных классов, интефейсов и трейтов, решающих определённую задачу,
например, ведение логов, парсинг RSS или обработка HTTP запросов. Зачастую компоненты используют друг друга и
отслеживать такие зависимости вручную было бы чрезмерно хлопотно.

Список компонентов можно взять на [https://packagist.org]()

Для управления библиотеками в PHP используется утилита, называемая Composer. Строго говоря, Composer не является
менеджером пакетов, т.к. не осуществляет компиляцию и установку ПО, однако его функции близки к понятию менеджера
пакетов. Существует множество способов установить Composer, в зависимости от используемой ОС или IDE.

### Установка Composer в Windows

[https://getcomposer.org/Composer-Setup.exe]()

Установка производится в диалоговом режиме, инсталлятор сам найдёт php.exe в системе, пропишется в PATH и
т.д.Единственное, что нужно сделать самостоятельно - это разрешить расширение OpenSSL, раскомментировав в php.ini строку

```
extension=php_openssl.dll
```

Для проверки в командной строке введите composer --version Альтернативный способ:

1. php -r "readfile('https://getcomposer.org/installer');" | php
2. создать файл composer.bat со строкой: @php "%~dp0composer.phar" %*
3. поместить composer.bat и composer.phar в каталог из PATH

### Использование в PHPStorm

Инициализировать Composer для существующего проекта можно через tools-composer. Init composer позволяет указать, где
находится composer.phar, скачать его, если ещё не скачан и создать composer.json по умолчанию. Файл по умолчанию
содержит описание вашего проекта, на случай если вы будете распространять его как пакет. В том же меню можно добавлять
зависимости. Можно создать проект сразу с поддержкой Composer и указанием всех необходимых зависимостей через File-New
project-Composer project.

### Конфигурирование Composer

Настройки для проекта хранятся в файле composer.json. В самом простом случае там содержатся только зависимости, но так
же этот файл может и должен описывать наш проект, особенно если мы планируем создать модуль для packagist.

#### Ключ require

```json
{
  "require": {
    "monolog/monolog": "2.0.*"
  }
}
```

Каждый пакет имеет имя и версию. Имя указывается в формате <имя производителя>/<имя пакета>, например, psy/psysh. В
версии * означает, что любая версия от 1.22.0 до 1.23.0 подойдёт. Другие варианты задания версии - ">=1.17.0 <1.18.0", "
1.17.0 - 1.18.0", "~1.17.0". Можно и явно указать конкретную версию.

Для первичной настройки следует выполнить команду __composer install__. Будут скачаны все нужные пакеты и их
обязательные зависимости, а в выводе будут указаны рекомендуемые дополнительные. В той же папке будут созданы файл
composer.lock с информацией об установленных пакетах и папка vendor с самими пакетами. Обычно эту папку добавляют в
исключения систем контроля версий - её содержимое несложно скачать заново. Если файл composer.lock существует, команда
использует данные из него — это полезно для фиксации окружения, будут использованы те же версии всех компонентов. Для
обновления конкретного компонента используйте composer update <имя/компонента>

Composer создаёт в проекте папку vendor, которая служит корнем для всех установленных модулей. Эту папку следует
добавить в исключения системы контроля версий, файлы composer.json и composer.lock напротив, надо коммитить - их
достаточно, чтобы установить их снова, когда потребуется развернуть проект.

Если требуется обновить версию пакета до последней версии, удовлетворяющей composer.json (например, там указана 1.2.*,
установлена и прописана в composer.lock 1.2.1, а уже вышла версия 1.2.4), нужно использовать команду __composer update <
название/пакета>__. Можно обновить все пакеты, если выполнить только __composer update__.

#### Псевдопакеты платформы

В секции require можно указывать названия особых пакетов, которые не соответствуют реальным модулям, а просто указывают
требования к системе, чтобы проект работал:

* ```php``` - указывает требуемую версию PHP, например, ^7.1. Если требуется 64-битный PHP, можно указать php-64bit
* ```ext-<name>``` - можно указать требуемые расширения PHP. Версия как правило не имеет значения, т.к. привязана к версии
  самого PHP, поэтому можно указать *
* ```lib-<name>``` - можно указать требуемые библиотеки. Вместо <name> поддерживаются curl, iconv, icu, libxml, openssl, pcre,
  uuid, xsl.

Команда __composer show --platform__ показывает все доступные псевдопакеты

#### Автозагрузка

Для того, чтобы использовать установленные при помощи composer модули, нужно подключить сгенерированный composer файл
vendor/autoload.php

```injectablephp
require __DIR__ . '/vendor/autoload.php';
```

После этого просто используем классы, как если бы они были частью нашего проекта. Если нужно, чтобы этот автозагрузчик
обрабатывал и классы нашего проекта, нужно использовать секцию __autoload__ в composer.json

```json
{
  "autoload": {
    "psr-4": {
      "Acme\\": "src/"
    }
  }
}
```

Здесь Acme - это корень пространства имён, а src/ - корневая папка в файловой системе проекта, а дальше - вложенные
пространства имён и папки идут параллельно, в соответствии с PSR-4. После внесения изменений в эту секцию конфига, нужно
выполнить __composer dump-autoload__

Можно добавлять новые пространства имён динамически. Для этого можно получить объект автозагрузчика и вызвать его метод:

```injectablephp
$loader = require __DIR__ . '/vendor/autoload.php';
$loader->addPsr4('Acme\\Test\\', __DIR__);
```

### Подробнее о composer.json

Многие из параметров используются если мы разрабатываем библиотеку для composer, пригодную для публикации на packagist.
Если хочется покопаться в схеме, которую сам композер использует для проверки собственного конфига (__composer
validate__), она есть [здесь](https://getcomposer.org/schema.json).

#### Корневые параметры

Параметры ниже используются на верхнем уровне файла и описывают наш проект, а не пакеты зависимостей

* name - название проекта. Должно состоять из имени вендора и собственного имени проекта, разделённых /. Каждое из этих
  имён должно состоять из слов (состоящих из маленьких латинских букв и цифр), при необходимости разделённых -, . или _,
  например, igorw/event-source

* description - короткое описание пакета, обычно в одну строку

* version - версия пакета. Обычно это не нужно - packagist умеет определять версию по тегу в VCS. Формат версии - X.Y.Z,
  vX.Y.Z, плюс опциональные суффиксы -dev, -patch (-p), -alpha (-a), -beta (-b), -RC

* type - тип пакета. По умолчанию это library, так же поддерживаются project (мы обычно будем использовать его);
  metapackage - пустой пакет, который нужен чтобы вынудить composer установить его зависимости; composer-plugin - для
  реализации сложных инсталяторов, дополняющих composer. Так же могут быть определены и дополнительные типы, например,
  symfony-bundle, wordpress-plugin или typo3-cms-extension

* keywords - опциональный массив ключевых слов, используется для поиска и фильтрации. Примеры: logging, events,
  database, и т.д.

* homepage - опциональный URL сайта проекта.

* readme - опциональный относительный путь к документу readme

* time - опциональная дата версии в формате YYYY-MM-DD или YYYY-MM-DD HH:MM:SS

* license - лицензия пакета, опционально но настоятельно рекомендуется. Строка или массив строк. В принципе может быть
  что угодно, но есть общепринятые виды лицензий:
    * Apache-2.0
    * BSD-2-Clause
    * BSD-3-Clause
    * BSD-4-Clause
    * GPL-2.0-only / GPL-2.0-or-later
    * GPL-3.0-only / GPL-3.0-or-later
    * LGPL-2.1-only / LGPL-2.1-or-later
    * LGPL-3.0-only / LGPL-3.0-or-later
    * MIT Для closed-source проектов можно использовать "proprietary"

* authors - авторы проекта. Это массив объектов со свойствами name, email, homepage и role, например:

```json
{
  "authors": [
    {
      "name": "Nils Adermann",
      "email": "naderman@naderman.de",
      "homepage": "https://www.naderman.de",
      "role": "Developer"
    },
    {
      "name": "Jordi Boggiano",
      "email": "j.boggiano@seld.be",
      "homepage": "https://seld.be",
      "role": "Developer"
    }
  ]
}
```

* support - разная информация для получения поддержки по поводу проекта, опционально. Объект, включающий в себя любой
  набор полей:
    * email
    * issues - URL багтрекера проекта
    * forum
    * wiki
    * irc - IRC канал поддержки в формате irc://server/channel.
    * source - URL для скачивания исходного кода проекта
    * docs: URL документации.
    * rss: URL ленты RSS.
    * chat: URL чата.

* funding - список объектов, описывающих способы поддержать проект финансово. Формат - массив объектов с полями type и
  url, где в type - название краудфандинга, например, patreon или tidelift.

#### Ссылки на пакеты

В блоках require и require-dev помимо ограничения на номер версии можно указать требуемую стабильность:

```json
{
  "require": {
    "monolog/monolog": "1.0.*@beta",
    "acme/foo": "@dev"
  }
}
```

#### require-dev

Работает как __require__. В этом блоке перечисляются зависимости, требуемые только для разработки, тестирования и так
далее. __composer install__ и __composer update__ поддерживают флаг --no-dev, позволяющий игнорировать эту секцию при
установке в проде.

#### conflict

Список пакетов, которые несовместимы с проектом. Синтаксис как и у require, указываем диапазоны версий. Если нужно
указать, например "меньше версии 1.0 или версия 1.1 и далее" можно использовать знак ||:
"<1.0 || >=1.1".

#### replace

Можно указать пакеты, которые заменяются данным пакетом. При помощи этого блока можно обработать случай, когда нам нужно
заменить пакет его форком с другим именем.

#### suggest

В этой секции можно перечислить пакеты, которые не обязательный, но рекомендуются к установке и могут улучшить работу
проекта. Вместо указания версии указывается произвольное текстовое описание:

```json
{
  "suggest": {
    "monolog/monolog": "Allows more advanced logging of the application flow",
    "ext-xml": "Needed to support XML format in class Foo"
  }
}
```

#### autoload

Кроме поддержки PSR-4, в этой секции поддерживаются PSR-0, classmap (генерирует файл
vendor/composer/autoload_classmap.php, ищущий нужные классы во всех перечисленных папках) и files, в котором можно
задать массив файлов, которые должны подключаться к каждому запросу. Подробнее в документации.

#### repositories

Если требуется указать репозитории кроме Packagist, данная секция позволяет это сделать. Можно задать сайт который
эмулирует логику packagist (отдаёт файл packages.json, в котором перечислены ссылки на composer.json и требуемые для
установки файлы), vcs (ссылка на репозиторий в git, svn, hg или fossil) или package, в котором по сути содержится
вложенный composer.json. Подробнее [тут](https://getcomposer.org/doc/05-repositories.md).

#### config 

Секция, в которой можно задать множество параметров, актуальных только для проектов. Подробно об этом в [документации](https://getcomposer.org/doc/06-config.md)

#### scripts

Секция которая позволяет задать дополнительные скрипты на разные этапы установки. Подробно об этом в [документации](https://getcomposer.org/doc/articles/scripts.md)


### Важные пакеты

#### psr/log

Содержит интерфейсы для PSR-3

#### monolog/monolog

Самая популярная реализация PSR-3, поддерживает десятки видов логирования.

#### psr/http-message
Содердит интерфейсы для PSR-7

#### PHP_CodeSniffer

Дополнение для проверки соответствия PSR-12: squizlabs/php_codesniffer Добавляются скрипты phpcs - для проверки стиля,
phpcbf - для автоисправления.
  
  

