# Модульное тестирование. PHPUnit
 
 ## Модульное тестирование
 Под модульным тестированием подразумевают тестирование программного продукта отдельными минимальными фрагментами (обычно речь идёт о функциях и методах объектов), в отличие от интеграционного тестирования, когда тестируется связка компонентов или весь продукт в целом и функционального тестирования, в котором тестируется логически завершённая часть функционала. 
 
 ### Автотесты
 Обычно с модульным тестированием связывают понятие "автоматического тестирования", вплоть до того, что многие разработчики ставят между этими понятиями знак равенства. Автоматический тест - это код, который тестирует другой код. В связке с модульным тестированием, как правило, автотест - это некая функция, проверяющая корректную работу проверяемой функции. Автотесты при правильном подходе должны запускаться при любом изменении покрытого этими тестами кода.
 
 ### TDD
 Test-driving development, разработка через тестирование - это техника разработки ПО, при которой первичным является создание теста, затем пишется код, который этот тест проходит и уже затем производится вся необходимая оптимизация и рефакторинг с целью удовлетворения стандартов, при условии, что тест продолжает исполняться. К плюсам TDD можно отнести то, что принципиальная тестируемость кода становится обязательным требованием, что почти всегда приводит к улучшению дизайна приложения - коротким методам с единственной ответственностью, а также повышает уверенность разработчика в том, что всё идёт правильно.
 
 ### Когда НЕ нужны автотесты?
 Создание модульных автотестов приводит к необходимости написания вдвое большего количества кода, но при этом значительно снижает время на отладку, особенно в часто изменяемом коде. Без автотестов можно и нужно обходиться в следующих случаях: 
 * Слишком маленький проект - нет смысла тестировать сайт-визитку на 5 страниц без особенно сложной логики
 * Сжатые сроки и недолговечный проект - например, демонстрационный проект для выставки, который будет 1-2 дня работать на стенде и создаваться будет пару недель
 * Проект, в котором много ввода-вывода и мало логики
 
 ## PHPUnit
 
 ### Инструментарий для тестирования
 Для организации тестирования как правило используют специальные инструменты, сильно облегчающие написание тестов. Общепризнанным стандартом для организации тестирования любого уровня в PHP является фреймворк PHPUnit. Мы будем рассматривать его использование именно в контексте модульных тестов, хотя ими его применение не ограничивается.
 Рекомендуется организовывать проект следующим образом, если нет других договорённостей: весь тестируемый код должен находиться в подпапке app проекта, а все тесты - в подпапке tests. Это сильно облегчает конфигурирование.
 
 ### Установка PHPUnit
 Скачать последнюю версию можно по ссылке: https://phar.phpunit.de/phpunit.phar
    Для работы с PHP архивами (PHAR) нужно разрешить их использование в php.ini: 
    suhosin.executor.include.whitelist = phar
    
Для Windows необходимо сделать следующее: 
 1. Добавить каталог с phpunit.phar в переменную среду PATH
 1. Создать обёртку в том же каталоге, файл phpunit.cmd со следующим содержимым: @php "%~dp0phpunit.phar" %*
 1. Для проверки выполнить в консоли: phpunit --version

 
 ### Использование в PHPStorm
 Помимо разрешения phar в php.ini, необходимо проделать следующее:
 1. Скопировать phpunit*.phar в корневой каталог проекта
 1. Открыть настройки проекта (ctrl-alt-s)->Languages and Frameworks->PHP->Test Frameworks
 1. Нажать +, выбрать PHPUnit Local
 1. Выбрать Path to phpunit.phar, указать путь к phar-файлу в корне вашего проекта. 
 
 ### Composer
 Как вы уже могли заметить по этому проекту, PHPUnit поддерживается и в виде модуля, устанавливаемого через Composer:
 
```
composer require --dev phpunit/phpunit ^9.5
```
 
 Ключ --dev обеспечивает установку PHPUnit только для дев-среды, на прод мы заливаем то что уже протестировано
 
 ### Первый тест
 MyClass.php
 
 ```injectablephp
<?php
 class MyClass {
 	public function power($x, $y)
 	{
 		return pow($x, $y);
 	}
 }
```

MyClassTest.php
```injectablephp
<?php

declare(strict_types=1);

require_once 'MyClass.php';

use PHPUnit\Framework\TestCase;

class MyClassTest extends TestCase {
 	public function testpower()
 	{
 		$my = new MyClass;
 		$this->assertEquals(8, $my->power(2,3));
 	}
 }
``` 

### Структура теста
* Для каждого тестируемого класса с названием \<class\> создаём тестовый класс с именем \<class\>Test и помещаем в файл \<class\>Test.php
* Внутри тестового файла импортируем тестируемый класс и подключаем через use его пространство имён, а также пространство имён PHPUnit\Framework\TestCase
* Тестовый класс должен наследоваться от TestCase
* Названия методов, обеспечивающие непосредственное тестирование должны начинаться с test
* Методы должны быть публичными и содержать вызов 1 или более методов TestCase, осуществляющих непосредственно проверку (начинаются на assert, далее будем называть их "утверждение")
 
### Запуск тестов в консоли
 ```phpunit <путь к каталогу с тестами>```
 
 Если всё сделали правильно, увидим примерно следующий вывод:
 
 ```
 c:\Projects\myProject> phpunit tests
 PHPUnit 6.4.3 by Sebastian Bergmann and contributors.
 …   3/3 (100%)
 Time: 100ms, Memory: 2.00MB
 
 OK (3 tests, 5 assertions)
```

 В первой строке выводится версия PHPUnit, во второй - цепочка символов, означающих пройденные тесты (.), проваленные (F), исключения (E); общее количество пройденных тестов и общее количество тестов, процент прохождения тестов, в следующей строке - статистические данные по времени прохождения тестов и памяти, в последней строке - итог: все ли тесты пройдены, сколько всего тестов и сколько в них утверждений.
 
 ### Запуск тестов в PHPStorm
 Нужно настроить конфигурацию запуска, осуществляющую тестирование
 * Run->Edit configurations
 * +-> PHPUnit
   * Name: UnitTest, Test scope: Directory (указать каталог с тестами)
   * Custom working directory: (каталог с тестами) - в случае если внутри тестов пути в проекте указываются относительно этого каталога
 После этого тестирование вызывается как обычный запуск с требуемой конфигурацией.
 
 ### Порядок разработки
 * Проектируем, описывая классы, методы, их ввод и вывод
 * Создаём пустые методы классов, возвращающие значения по умолчанию (нули для чисел, "" для строк, new … для объектов)
 * Создаём тесты для каждого метода, тестирующие все возможные ветки кода (например, если предвидится ветвление - для каждой ветки отдельный тест)
 * Запускаем тесты, убеждаемся, что они не проходят (кроме тестов на значения по умолчанию)
 * Пишем код, чтобы начали проходить
 * При необходимости изменений, пишем (и проверяем на фейл) новые тесты, затем новый код в тестируемые классы, убеждаемся, что проходят и новые, и старые тесты.
 
 assertEquals(), assertSame()
 Самые простые и часто используемые утверждения. В качестве первого аргумента возвращаем ожидаемое значение, во второй 
 должен подставляться фактический результат. 
 
 assertEquals проверяет в значении ==, assertSame - в значении === (здесь и далее $this-> буду опускать, все упомянуте 
 методы - методы класса TestCase и будут унаследованы нашим тестовым классом)
 
 ```injectablephp
assertSame('2204', 2204);
```
В одном тесте может быть сколько угодно утверждений, нормальная ситуация, когда внутри теста проверяется значение 
некоторого свойства класса до изменения, затем вызывается метод, изменяющий это свойство и проверяется ещё раз свойство 
после изменения. Чтобы тест считался пройденным, должны выполниться все утверждения.
 
 ### Аннотации
 PHPUnit поддерживает специальные директивы, расширяющие возможности тестов и  повышающие читаемость. Для указания таких 
 директив, используются phpDoc для тестовых методов. Синтаксис конкретных директив рассмотрим по мере их появления, 
 называть такие управляющие комментарии будем аннотациями. В примере ниже - аннотация @group, позволяющая запускать 
 только тесты указанных групп или всех, кроме них при помощи ключей командной строки --group и --exclude-group (бывает 
 удобно в больших проектах, в которых меняется изолированный участок)
```injectablephp
/**     
* @group specification     
*/   
public function testSomething()    
{
    /// some asserts
}
```

Поддержка атрибутов из PHP 8 появится в разрабатываемом PHPUnit 10, в актуальных PHPUnit версий 8 и 9 поддерживаются 
только аннотации в DocBlocks 
 
 
### Проверка исключений
 PHPUnit позволяет проверять корректное выкидывание исключений в ситуациях, когда они требуются. Для этого 
 непосредственно перед вызовом кода, который должен вызвать исключение, нужно добавить вызов метода
 
 ```expectException(<тип ожидаемого исключения>);```

другой способ - аннотация @expectedException:

```injectablephp
 /**
   * @expectedException MyException
   * @expectedExceptionCode 20
 */
 public function testExceptionWithErrorCode20()
 {
 	throw new MyException('Message', 20);
 }
``` 

### Другие утверждения
 Почти всегда можно обойтись assertEquals, но для читаемости тестов лучше использовать более специфические утверждения, например:
 assertNull($expr) - проверка выражения на null (аналогично, assertNotNull())
 assertNan($expr) - проверка выражения на NAN
 assertTrue($expr)  - проверка выражения на true (аналогично, assertFalse())
 
 
 
 ### Утверждения с массивами
 assertArrayHasKey($key, $array) - утверждает, что в массиве есть указанный ключ
 assertArraySubset($subarray, $array) - утверждает, что подмассив входит в массив
 assertCount($count, $array) - утверждает, что массив содержит указанное количество элементов
 
 ### Фикстуры
 При тестировании класса со сложной инициализацией или требующего правильного уничтожения (а на самом деле вообще 
 всегда) рекомендуется вынести в отдельные методы "подготовку перед тестом" и "наведение порядка после теста". Для этого 
 нужно переопределить методы 
 * setUp() - вызывается перед выполнением каждого теста. Часто туда выносят импорт и вызов конструктора тестируемого класса
 * tearDown()  - вызывается после выполнения каждого теста
 
 В итоге каждый тест начинает работать с одинаковыми стартовыми данными.
 Текущее состояние тестируемого объекта называется "фикстурой" 
 
 ### Зависимые тесты
 В идеале, тесты должны быть предельно атомарными и независимыми, однако при необходимости можно указать, что тесты 
 являются зависимыми и результат выполнения одного теста подставляется в другой (это тоже называется фикстурой). Для 
 этого используется аннотация @depends
 
 ```injectablephp
public function testEmpty()
 	{
     		$stack = [];
     		$this->assertEmpty($stack);
     	return $stack;
 	}

/**
 * @depends testEmpty
 */
public function testPush(array $stack)
 	{
     		array_push($stack, 'foo');
     		$this->assertEquals('foo', $stack[count($stack)-1]);    	
     	return $stack;
 	}
```

 
 ### Провайдеры данных 
 Обычно при тестировании однотипной логики с разными входными параметрами удобно не писать несколько тестов, а 
 использовать один тест, которому указать входные параметры и через аннотацию @dataProvider: передать наборы входных 
 параметров, полученных от указанного метода:
 
 ```injectablephp
 /**
 * @dataProvider additionProvider
*/
public function testAdd($a, $b, $expected)
    {
        $this->assertEquals($expected, $a + $b);
    }

public function additionProvider()
    {
        return [
                [0, 0, 0],
                [0, 1, 1],
                [1, 1, 3]
               ];
    }
```
  
 #### Дополнительные приятные возможности провайдеров:
 * Провайдер может возвращать не список, а ассоциативный массив. В таком случае при провале теста для одного из наборов 
 данных в выводе PHPUnit будет видно, какой именно тест провалился (будет выведен ключ соответствующего элемента)
 * Провайдер может возвращать вместо массива любой итератор, например, для считывания тестовых данных из файла. Можно 
 использовать это и для автоматической генерации тестовых данных при каждом запуске случайным образом, но делать этого, 
 конечно же, не нужно. Тесты должны быть одинаковыми при каждом запуске!
 
 ### Тестирование вывода
 При правильном проектировании, методы, выводящие что-либо в браузер (или консоль) должны быть лишены какой-либо логики, 
 однако если вы пишете тесты для существующего проекта, может потребоваться проверять, что именно некоторый метод 
 выводит на экран.
 
 expectOutputString($string)  - указывает, что последующий код должен вывести в выходной поток (любым способом - echo, 
 var_dump и т.д.) указанный текст. 
 Существуют и другие методы для работы с выводом.
 
 ### Дополнение для отладки
 Для включения возможностей отладки в php необходимо подключить модуль xdebug.
 
 https://xdebug.org - здесь можно скачать библиотеку для windows и найти инструкции для установки модуля под MacOs X и 
 Linux.
 
 В php.ini:
 ```ini
[xdebug]
zend_extension="<full_path_to_dll>.dll"
xdebug.remote_enable=on
xdebug.remote_connect_back=on
```
 php -v должен показывать "with xdebug"
 
 
### Анализ покрытия
 PHPUnit умеет анализировать метрики покрытия кода - т.е. статистику, сколько и каких файлов, классов, методов и строк 
 кода покрыты пройденными тестами. Таким образом можно установить, какие участки кода мы не покрыли тестами и исправить 
 это при необходимости.
 Удобнее всего это использовать с PHPStorm: при запуске тестов при помощи кнопки "Run with coverage" PHPStorm сам 
 проанализирует вывод PHPUnit и подсветить файлы и строки кода, которые остались непротестированными.
 Для этого в настройках конфигурации нужно указать папку, для которой будет проводиться анализ, в Test Runner options:
 
 --whitelist <полный путь к папке с тестируемым кодом>
 
 Внимание! Анализ покрытия кода работает только со включенным xDebug
 
### Неполный тест
 В начале разработки может оказаться, что для некоторых тестов у нас недостаточно сведений и написать сам тест мы не 
 можем, хотя и знаем, что он нужен. Чтобы не забыть о таких тестах, мы можем использовать аналог todo: пометить тест как 
 неполный при помощи метода 
 
 ```markTestIncomplete([$message])``` 
 Такой тест в выводе консоли будет помечен символом "I" и в итогах тестирования PHPUnit будет писать, что есть 
 незавершённые или пропущенные тесты.
 
### Пропущенные тесты
Некоторые тесты могут быть выполнены не всегда. Очевидный пример - тесты, зависящие от других тестов. Если тест не 
выполнился, зависящие от него будут автоматически пропущены. Есть возможность пометить тест как пропускаемый явно, 
например, если не выполняется какое-то условие, при помощи метода ```markTestSkipped([$message])```.
Если нужно пропустить тестирование класса целиком, можно вызвать этот метод в setUp()
Другой вариант - использование аннотации ```@requires <тип> <значение>```, позволяющей задать явно условия, при 
невыполнении которых тест нужно пропустить. Поддерживаются следующие типы: PHP \<version\>; PHPUnit \<version\>; 
OS \<regexp\>; function \<name\>; extension \<name\>

```injectablephp
/**
 * @requires extension php_pgsql
 */
final class DatabaseTest extends TestCase
{
    /**
     * @requires PHP >= 7.4
     */
    public function testConnection(): void
    {
        // Test requires the pgsql extension and PHP >= 7.4
    }

    // ... All other tests require the pgsql extension
}
```
 
 
 ### Список литературы
 * [официальная документация к PHPUnit последней версии](https://phpunit.readthedocs.io/ru/latest/)
 * [русская статья по PHPUnit для начинающих](http://phpprofi.ru/blogs/post/24) 
 
