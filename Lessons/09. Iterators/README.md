# Итераторы

В язык PHP встроены специальные сущности, позволяющие динамически генерировать данные или выдавать их порционно по мере
необходимости. Мы столкнулись с подобным поведением когда получали построчно вывод SQL-запроса. Это позволяет сильно
экономить память (по сравнению с сохранением всех данных в большой массив).

# Стандартное поведение foreach

Вообще говоря, в PHP по умолчанию для любого объекта возможен перебор его полей циклом `foreach`. Если внутрь `foreach`
подставить объект без заданной логики перебора, будут по очереди выбраны все его открытые поля.
Cпециальным образом это работает для массивов, а также объектов встроенного класса `Generator` и стандартного
класса `DatePeriod`. Для своих классов мы можем специальным образом задать особый объект - "представитель", который
инструктирует `foreach`, как именно перебирать объект нашего класса.

[Пример](Examples/1foreach.php)

# Интерфейсы `Iterator` и `IteratorAggregate`

Интерфейс `Iterator` содержит следующие методы, позволяющие циклу `foreach` его перебирать:

- `current()`  - возвращает текущее значение;
- `key()` - возвращает текущий ключ;
- `next()` - перемещает указатель на следующий элемент;
- `rewind()` - сбрасывает указатель в начало;
- `valid()` - проверяет, что последнее значение ещё не пройдено.

[Пример](Examples/2iterator.php)

Эти методы можно вызывать и вне цикла `foreach` для неявного перебора.

Если класс должен позволять итерировать по объекту в разных циклах независимо, можно использовать
интерфейс `IteratorAggregate` имеющий 1 метод: `getIterator()`, который должен вернуть объект, реализующий
интерфейс `Iterator` - вспомогательный класс, умеющий итерировать внешний класс и содержащий независимый указатель.

## Как работает итератор в PHP?

Рассмотрим работу с итератором в foreach. Пусть $d - объект класса, реализующего `IteratorAggregate`

```PHP
foreach ($d as $path => $entry) { 
// ... 
}
```

c точки зрения PHP, этот код эквивалентен следующему:

```PHP
$it = $d->getIterator(); 
for($it->rewind(); $it->valid(); $it->next()) {
    $path = $it->key();
    $entry = $it->current();
    // ...
}
unset($it);
```

Как видите, используются все 5 методов интерфейса Iterator и единственный метод IteratorAggregate.

# `Generator`

Класс `Generator` - специальный класс, реализующий интерфейс `Iterator`. Явно инстанцировать его не нужно - он
возвращается из функций, использующих ключевое слово `yield`. В момент, когда выполнение функции доходит до `yield` оно
встаёт на паузу, а соответствующие методы интерфейса `Iterator` возвращают значение (`yield <value>`) или пару
ключ-значение (`yield <key>=><value>`). Вызов метода `next()` (явный или неявный внутри `foreach`) продолжает выполнение
до следующего `yield` или завершения функции.

[Пример](Examples/3generator.php)

## Возвращаемое значение

Генератор может возвращать значение при помощи `return`. Это может быть нужно, например, чтобы посчитать количество
выданных значений. Для этого у класса `Generator` определён метод `getReturn()`. С этим методом нужно быть осторожными -
если вызвать его раньше, чем выполнение кода генератора дойдёт до `return` (или в коде вообще отсутствует возвращаемое
значение) - будет выброшен `Exception`.

## Использование генераторов для обработки массивов

[Пример](Examples/4genetator_array.php)

## Делегирование генераторов

Генераторы могут получать значения из других генераторов при помощи ключевого слова `from` после `yield`

[Пример](Examples/5yield_from.php)

## Экономия ресурсов

Канонический пример того, как генераторы позволяют экономить ресурсы (даже в документации на php.net есть) -
переопределение встроенной функции `range()`, возвращающей массив целых чисел между заданными начальным и конечным
значением.

[Пример](Examples/6range.php)

## Передача значения внутрь генератора

Если нужно не только считать из генератора значение, но и отдать его внутрь, можно воспользоваться методом `send()`, а
внутри генератора считывать полученное значение так же через 'yield':

```php
function  mygen() {
// ...
$s = yield;
// ...    
}

mygen()->send("42");
```

Аналогичным образом можно вызвать исключение внутри генератора при помощи метода `throw()`:

```php
function  mygen() {
// ...
try {
// yield;
}
catch (Exception $ex) {
// ...
}
// ...    
}

mygen()->throw(new Exception("Тут случилось страшное"));
```

# Стандартные итераторы

## DatePeriod

DatePeriod

Класс позволяет создать итератор для обхода последовательности дат (`DateTime`) следующих друг за другом через
определённый интервал. Конструктор класса принимает 3 параметра:

* `DateTime` - начало периода
* `DateInterval` - шаг, с которым генерируются даты
* `int` - количество итераций.

```php
$now = new DateTime();
$step = new DateInterval('P1W');
$period = new DatePeriod($now, $step, 5);
foreach ($period as $datetime) {
… // получим 6 дат, первая из которых - текущая, а затем 5 отстоящих от неё на 1 неделю
}
```

[Пример](Examples/7datePeriod.php)

## Библиотека SPL

В PHP встроено множество готовых классов и интерфейсов. Их собрание называется SPL - Standart PHP Library. Полностью мы
эту библиотеку рассматривать не будем, в контексте лекции она интересна нам наличием множества классов-итераторов и
интерфейсов-итераторов. Многие из этих итераторов принимают на вход конструктора другие итераторы и производят над ними
дополнительные действия. Это позволяет составлять цепочки итераторов, выполняющих довольно сложную логику.

### DirectoryIterator

Позволяет перебирать файлы из указанного каталога. Каждый элемент - не просто название файла, а объект с разными
методами, позволяющими получить информацию о файле.

[Пример](Examples/8directoryIterator.php)

### FilterIterator

Абстрактный класс, реализующий фильтрацию значений, возвращаемых другими итераторами. Единственный абстрактный метод в
нём - `accept()`, который решает, проходит данное текущее значение (`$this->current()`) под фильтр или нет. Другие
важные
методы:

* `__construct(Iterator $it)` - конструктор принимает на вход другой итератор;
* `getInnerIterator()` - позволяет получить внутренний итератор, переданный в конструктор при создании.

### LimitIterator

Позволяет осуществить постраничный вывод того, что вернул какой-то другой итератор. Конструктор принимает на вход другой
итератор, начальную позицию (0 по умолчанию) и смещение относительно этой позиции. В итоге при итерации через foreach
будет обрабатываться только заданный диапазон.
```php
$limit = new LimitIterator(new DirectoryIterator('.'), 0, 5)
```
