# PDO

PHP Data Objects - это простой универсальный интерфейс для доступа к базам данных в PHP. Для каждой конкретной базы
данных нужен свой драйвер, реализующий этот интерфейс. Драйверы к популярным БД включаются в поставке PHP для Windows,
для Linux их нужно устанавливать отдельно.

## Подготовка

Рассмотрим на примере PostgreSQL.

<details>
<summary>Postgres или PostgreSQL?</summary>
Исторически, существовала не SQL БД с названием Postgres. После того, как была реализована в ней поддержка SQL, название 
было изменено на PostgreSQL, но прежнее наименование тоже имеет право на существование как альяс. Главное что нужно 
помнить: название Postgre неверно, никогда так не называйте.
</details>

Windows:
php.ini

```
extension=php_pgsql.dll
```

Linux:

```
sudo upt-get install php-pgsql
```

## Подключение к БД

```injectablephp
$conStr = sprintf("pgsql:host=%s;port=%d;dbname=%s;user=%s;password=%s", 
                $host, $port, $database, $user, $password);
$pdo = new \PDO($conStr); 
$pdo->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);  
/* Можно передавать параметры в конструктор, а не строку состояния
*  $pdo = new \PDO(
*      "pgsql:host=localhost;port=5432;dbname=test42",
*      $user,
*      $password,
*      [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION]
*  );
*/
```

По умолчанию, PDO в случае неудачи любой команды возвращает false, а чтобы узнать, что пошло не так, нужно обращаться к
специальным методам. Мы такой вариант использования даже не будем рассматривать и сразу переключим PDO в режим
выкидывания исключений.

## Получение данных

```injectablephp
$query = "SELECT * FROM students";
$stud = $pdo->query($query);
try {
	while ($student = $stud->fetch()) 
		{echo $student['firstname']." ".$student['lastname'];}
} catch (PDOException $e) {
	echo $e->getMessage();
}
```

Массив, который вернёт fetch можно настраивать

```injectablephp
$stud->fetch(PDO::FETCH_ASSOC);
```

Варианты:

* PDO::FETCH_ASSOC - Как ключи будут использованы названия столбцов.
* PDO::FETCH_NUM - Как ключи будут использованы номера столбцов по порядку.
* PDO::FETCH_BOTH - по умолчанию, значения будут дублироваться с номерами и названиями столбцов. Есть и другие, в том
  числе, можно настроить возврат класса.

Другой способ - получать записи не по одной, а все сразу массивом:

```injectablephp
$query->fetchAll();
```

## Другие запросы

```injectablephp
$query = "CREATE TABLE students (
student_id INT(11) NOT NULL AUTO_INCREMENT,
firstname TINYTEXT NOT NULL,
lastname TINYTEXT NOT NULL,
PRIMARY KEY (student_id))";
$res = $pdo->exec($query);
```

Метод exec используется для запросов, на которые не ожидается содержательного ответа, в отличии от query, которая служит
для select-запросов.

## Запросы с параметрами

Для update- и insert- запросов (да и для select с полученными извне параметрами) удобно использовать подготовленные
запросы, в которых меняются только значения. Это будет работать быстрее, чем менять каждый раз SQL и выглядит изящнее

```injectablephp
$st = $pdo->prepare("SELECT uri FROM uris WHERE parent_id=:id");
$st->bindValue(":id", $id);
$st->execute();
```

:id - это место подстановки значения. Можно так же передать в execute массив подстановки:

```injectablephp
$st = $pdo->prepare("SELECT uri FROM uris WHERE parent_id=:id");
$st->execute([":id"=> $id]);
$result = $st->fetchAll();
```

Если мы используем нумерованный массив (список), то вместо ключей :0, :1 и т.д. можно указать ? для нумерации по
порядку:

```injectablephp
$st = $pdo->prepare("INSERT INTO students (firstname,lastname) VALUES (?,?)");
$st->execute(['Анон', 'Сычёв']);
```

PDO::prepare возвращает объект [PDOStatement](https://www.php.net/manual/ru/class.pdostatement.php), из которого можно
получить всю нужную информацию о запросе и установить параметры, а после execute - получить результаты.

## ORM

Как видим, PDO абстрагирует доступ к данным, позволяя выполнять типовые запросы к базам данных, но не абстрагирует саму
базу данных, для этого нужно реализовать дополнительную абстракцию над PDO. В парадигме ООП, такую обёртку называют
ORM (Object-Relation mapping). При этом используется один из паттернов, сопоставляющий базе данных, таблице базы данных,
запросу, результату выполнения запроса объекты определённых классов. Самыми распространёнными паттернами для ORM
являются
[Active record и Data Mapper](https://habr.com/ru/post/198450/), описанные в книге Мартина Фаулера «Шаблоны
корпоративных приложений»

В двух словах, отличия между ними следующие:

* В Active Record в объекте инкапсулируется хранение значений, сохранение их в базу данных и загрузка из базы данных.
  Объект соответствует 1 кортежу реляционной БД и содержит поля соответствующие полям в БД и методы для сохранения и
  получения значений из БД, а так же дополнительные методы для манипуляции полученными данными.

* В Data Mapper реализованы отдельные классы для хранения и обработки данных (т.н. бизнес-объекты) и отдельно - классы, сопоставляющие классы
  данных базе данных (мапперы).

Active Record интуитивно понятнее и проще в работе, но нарушает принцип единой ответственности (букву S из SOLID). Data
Mapper лучше с точки зрения слабой связности: одни и те же данные можно использовать с разными мапперами для работы с
разными БД или, например, сохранения в файл или отправки по сети; так же такие объекты облегчают поддержку и тестирование.


